<!DOCTYPE html>
<html lang="tr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MuG√∂l GAMES - Fruit Ninja</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            user-select: none;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #gameContainer {
            width: 100%;
            max-width: 500px;
            background: rgba(44, 62, 80, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        .header {
            text-align: center;
            margin-bottom: 20px;
        }

        .header h1 {
            color: #3498db;
            font-size: 20px;
            letter-spacing: 2px;
        }

        .header h2 {
            color: #ecf0f1;
            font-size: 28px;
        }

        #stats {
            display: flex;
            justify-content: space-around;
            background: rgba(52, 73, 94, 0.8);
            border-radius: 15px;
            padding: 15px;
            margin-bottom: 20px;
        }

        .stat {
            text-align: center;
        }

        .stat-label {
            color: #95a5a6;
            font-size: 14px;
        }

        .stat-value {
            color: #ecf0f1;
            font-size: 32px;
            font-weight: bold;
        }

        #canvasContainer {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            padding: 10px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        #gameCanvas {
            display: block;
            width: 100%;
            border-radius: 10px;
            cursor: crosshair;
        }

        .modal {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 1000;
            border: 3px solid #3498db;
            max-width: 90%;
        }

        .modal h2 {
            color: #3498db;
            font-size: 36px;
            margin-bottom: 20px;
        }

        .modal p {
            color: #ecf0f1;
            font-size: 18px;
            line-height: 1.8;
            margin: 15px 0;
        }

        .modal button {
            margin: 10px;
            background: linear-gradient(135deg, #27ae60, #229954);
            color: white;
            border: none;
            padding: 15px 40px;
            border-radius: 10px;
            font-size: 18px;
            cursor: pointer;
            font-weight: bold;
            transition: all 0.3s;
        }

        .modal button:hover {
            transform: scale(1.05);
        }

        #startScreen {
            display: block;
        }

        .slice-trail {
            position: absolute;
            pointer-events: none;
            width: 4px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 2px;
            z-index: 100;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.6);
        }

        .combo-text {
            position: fixed;
            font-size: 48px;
            font-weight: bold;
            color: #f39c12;
            text-shadow: 0 0 20px rgba(243, 156, 18, 0.8);
            pointer-events: none;
            z-index: 1001;
            animation: comboFloat 1s ease-out forwards;
        }

        @keyframes comboFloat {
            0% {
                transform: scale(0) rotate(-10deg);
                opacity: 1;
            }
            50% {
                transform: scale(1.2) rotate(5deg);
            }
            100% {
                transform: scale(1) translateY(-100px) rotate(0deg);
                opacity: 0;
            }
        }
    </style>
</head>
<body>
    <div id="gameContainer">
        <div class="header">
            <h1>MuG√∂l GAMES</h1>
            <h2>üçâ Fruit Ninja</h2>
        </div>

        <div id="stats">
            <div class="stat">
                <div class="stat-label">Puan</div>
                <div class="stat-value" id="score">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Combo</div>
                <div class="stat-value" id="combo">0</div>
            </div>
            <div class="stat">
                <div class="stat-label">Hayat</div>
                <div class="stat-value" id="lives">‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è‚ù§Ô∏è</div>
            </div>
        </div>

        <div id="canvasContainer">
            <canvas id="gameCanvas" width="460" height="600"></canvas>
        </div>
    </div>

    <div id="startScreen" class="modal">
        <h2>üçâ Fruit Ninja</h2>
        <p>Meyveleri kesmek i√ßin fareyi s√ºr√ºkleyin!</p>
        <p>üí£ Bombalara dokunmayƒ±n!</p>
        <p>‚≠ê Combo yaparak bonus puan kazanƒ±n!</p>
        <button onclick="startGame()">Oyuna Ba≈üla</button>
    </div>

    <div id="gameOver" class="modal">
        <h2>Oyun Bitti!</h2>
        <p>Puan: <span id="finalScore">0</span></p>
        <p>En Y√ºksek Combo: <span id="maxCombo">0</span></p>
        <button onclick="startGame()">Tekrar Oyna</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let score = 0;
        let lives = 10;
        let combo = 0;
        let maxCombo = 0;
        let active = false;
        let fruits = [];
        let particles = [];
        let sliceTrails = [];
        let lastMouseX = 0;
        let lastMouseY = 0;
        let mouseDown = false;
        let comboTimer = null;

        const fruitEmojis = ['üçé', 'üçä', 'üçã', 'üçå', 'üçâ', 'üçá', 'üçì', 'ü•ù', 'üçë', 'üçí'];
        const bombEmoji = 'üí£';

        class Fruit {
            constructor() {
                this.x = Math.random() * 360 + 50;
                this.y = 620;
                this.vx = (Math.random() - 0.5) * 2;
                this.vy = -14 - Math.random() * 4;
                this.rotation = 0;
                this.rotationSpeed = (Math.random() - 0.5) * 0.1;
                this.emoji = fruitEmojis[Math.floor(Math.random() * fruitEmojis.length)];
                this.isBomb = Math.random() < 0.08;
                if (this.isBomb) this.emoji = bombEmoji;
                this.sliced = false;
                this.size = 40;
                this.gravity = 0.4;
            }

            update() {
                this.vy += this.gravity;
                this.x += this.vx;
                this.y += this.vy;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }

            isPointInside(x, y) {
                const distance = Math.sqrt((x - this.x) ** 2 + (y - this.y) ** 2);
                return distance < this.size;
            }

            slice() {
                this.sliced = true;
                if (!this.isBomb) {
                    score += 10 + (combo * 5);
                    combo++;
                    if (combo > maxCombo) maxCombo = combo;
                    
                    if (combo >= 3) {
                        showComboText(this.x, this.y);
                    }
                    
                    clearTimeout(comboTimer);
                    comboTimer = setTimeout(() => {
                        combo = 0;
                        document.getElementById('combo').textContent = 0;
                    }, 1000);
                    
                    document.getElementById('score').textContent = score;
                    document.getElementById('combo').textContent = combo;
                    createParticles(this.x, this.y, this.emoji);
                    playSound('slice');
                } else {
                    lives--;
                    updateLives();
                    createExplosion(this.x, this.y);
                    playSound('bomb');
                    if (lives <= 0) {
                        endGame();
                    }
                }
            }
        }

        class Particle {
            constructor(x, y, emoji) {
                this.x = x;
                this.y = y;
                this.vx = (Math.random() - 0.5) * 10;
                this.vy = -5 - Math.random() * 5;
                this.life = 1;
                this.emoji = emoji;
                this.rotation = Math.random() * Math.PI * 2;
                this.rotationSpeed = (Math.random() - 0.5) * 0.3;
                this.size = 20 + Math.random() * 10;
            }

            update() {
                this.vy += 0.5;
                this.x += this.vx;
                this.y += this.vy;
                this.life -= 0.02;
                this.rotation += this.rotationSpeed;
            }

            draw() {
                ctx.save();
                ctx.globalAlpha = this.life;
                ctx.translate(this.x, this.y);
                ctx.rotate(this.rotation);
                ctx.font = `${this.size}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, 0, 0);
                ctx.restore();
            }
        }

        function createParticles(x, y, emoji) {
            for (let i = 0; i < 6; i++) {
                particles.push(new Particle(x, y, emoji));
            }
        }

        function createExplosion(x, y) {
            for (let i = 0; i < 20; i++) {
                const particle = new Particle(x, y, 'üí•');
                particle.vx = (Math.random() - 0.5) * 15;
                particle.vy = (Math.random() - 0.5) * 15;
                particles.push(particle);
            }
        }

        function showComboText(x, y) {
            const comboText = document.createElement('div');
            comboText.className = 'combo-text';
            comboText.textContent = `${combo}x COMBO!`;
            comboText.style.left = x + 'px';
            comboText.style.top = y + 'px';
            document.body.appendChild(comboText);
            setTimeout(() => comboText.remove(), 1000);
        }

        function updateLives() {
            const hearts = '‚ù§Ô∏è'.repeat(lives) + 'üñ§'.repeat(10 - lives);
            document.getElementById('lives').textContent = hearts;
        }

        function spawnFruit() {
            if (active) {
                fruits.push(new Fruit());
                setTimeout(spawnFruit, 1300 + Math.random() * 700);
            }
        }

        function draw() {
            ctx.clearRect(0, 0, 460, 600);

            // Update and draw fruits
            for (let i = fruits.length - 1; i >= 0; i--) {
                const fruit = fruits[i];
                fruit.update();
                fruit.draw();

                if (fruit.y > 650 || fruit.sliced) {
                    if (!fruit.sliced && !fruit.isBomb) {
                        lives--;
                        updateLives();
                        if (lives <= 0) {
                            endGame();
                        }
                    }
                    fruits.splice(i, 1);
                }
            }

            // Update and draw particles
            for (let i = particles.length - 1; i >= 0; i--) {
                const particle = particles[i];
                particle.update();
                particle.draw();

                if (particle.life <= 0) {
                    particles.splice(i, 1);
                }
            }

            if (active) {
                requestAnimationFrame(draw);
            }
        }

        function checkSlice(x, y) {
            for (const fruit of fruits) {
                if (!fruit.sliced && fruit.isPointInside(x, y)) {
                    fruit.slice();
                }
            }
        }

        function createSliceTrail(x1, y1, x2, y2) {
            const trail = document.createElement('div');
            trail.className = 'slice-trail';
            
            const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
            const angle = Math.atan2(y2 - y1, x2 - x1);
            
            trail.style.width = length + 'px';
            trail.style.left = x1 + 'px';
            trail.style.top = y1 + 'px';
            trail.style.transform = `rotate(${angle}rad)`;
            
            document.getElementById('canvasContainer').appendChild(trail);
            
            setTimeout(() => trail.remove(), 200);
        }

        canvas.addEventListener('mousedown', () => {
            mouseDown = true;
        });

        canvas.addEventListener('mouseup', () => {
            mouseDown = false;
        });

        canvas.addEventListener('mousemove', (e) => {
            if (!active) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.clientX - rect.left) * scaleX;
            const y = (e.clientY - rect.top) * scaleY;

            if (mouseDown) {
                checkSlice(x, y);
                if (lastMouseX !== 0 && lastMouseY !== 0) {
                    createSliceTrail(lastMouseX / scaleX + rect.left, lastMouseY / scaleY + rect.top, x / scaleX + rect.left, y / scaleY + rect.top);
                }
            }

            lastMouseX = x;
            lastMouseY = y;
        });

        canvas.addEventListener('touchstart', (e) => {
            e.preventDefault();
            mouseDown = true;
        });

        canvas.addEventListener('touchend', (e) => {
            e.preventDefault();
            mouseDown = false;
        });

        canvas.addEventListener('touchmove', (e) => {
            e.preventDefault();
            if (!active) return;
            
            const rect = canvas.getBoundingClientRect();
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;
            const x = (e.touches[0].clientX - rect.left) * scaleX;
            const y = (e.touches[0].clientY - rect.top) * scaleY;

            checkSlice(x, y);
            if (lastMouseX !== 0 && lastMouseY !== 0) {
                createSliceTrail(lastMouseX / scaleX + rect.left, lastMouseY / scaleY + rect.top, x / scaleX + rect.left, y / scaleY + rect.top);
            }

            lastMouseX = x;
            lastMouseY = y;
        });

        function playSound(type) {
            try {
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const oscillator = audioCtx.createOscillator();
                const gainNode = audioCtx.createGain();
                
                oscillator.connect(gainNode);
                gainNode.connect(audioCtx.destination);
                
                if (type === 'slice') {
                    oscillator.frequency.value = 1000;
                    gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.1);
                } else if (type === 'bomb') {
                    oscillator.type = 'sawtooth';
                    oscillator.frequency.value = 100;
                    gainNode.gain.setValueAtTime(0.5, audioCtx.currentTime);
                    gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.3);
                    oscillator.start(audioCtx.currentTime);
                    oscillator.stop(audioCtx.currentTime + 0.3);
                }
            } catch (e) {}
        }

        function startGame() {
            score = 0;
            lives = 10;
            combo = 0;
            maxCombo = 0;
            active = true;
            fruits = [];
            particles = [];

            document.getElementById('score').textContent = '0';
            document.getElementById('combo').textContent = '0';
            updateLives();
            document.getElementById('startScreen').style.display = 'none';
            document.getElementById('gameOver').style.display = 'none';

            spawnFruit();
            draw();
        }

        function endGame() {
            active = false;
            document.getElementById('finalScore').textContent = score;
            document.getElementById('maxCombo').textContent = maxCombo;
            document.getElementById('gameOver').style.display = 'block';
        }
    </script>
</body>
</html>
